from http.cookiejar import Cookie
from sys import byteorder
from Crypto import Cipher
import requests
from Crypto.Random import get_random_bytes
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES, PKCS1_OAEP
from hashlib import sha256, sha512
from hashlib import md5
from base64 import b64encode
from base64 import b64decode
import os
import sympy
import math
import random
os.system('clc' if os.name == 'nt' else 'clear')



class Assignment1Part2Part2(object):
    rsa_Moduli = 3072
    rsa_Salt = 32
    password = 'password'
    msg = b'Assignment1 Part2 Part2 message'
    msgTamper = b'Assignment1 Part2 Part2 tampered'


    def __init__(self):
        self.userInterface()


    def userInterface(self):
        nr = 0
        while(nr == 0):
            print("\033c", end="")
            print("Choice a nr.:")
            print("1 : With RSA lib")
            print("2 : With costume version of RSA Lib")
            print("3 : Back")
            nr = input()
        
            if nr == "1":
                self.rsa_psa_withLib()
            elif nr == "2":
                self.rsa_psa_withoutLib()
            elif nr == "3":
                print("Going back...")
            else:
                nr = 0
                input("Wrong input, press enter to continue...")


    def rsa_psa_withoutLib(self):
        print("Assignment1 Part2 Part2 : Starting rsa_psa")

        ##############Preparing##############
        print("\n\n##############Preparing##############")
        rsaKey = self.costume_rsakey_gen()
        print(f"\nPublic key:  (n={hex(rsaKey.n)}, e={hex(rsaKey.e)})")
        print(f"\nPrivate key: (n={hex(rsaKey.n)}, d={hex(rsaKey.d)})")

        sessionKey = self.sessionKey_gen()
        print("\nSessionKey : " + str(sessionKey)) 


        ##############Sending side##############
        print("\n\n##############Sending side############## ")
        encryptedRsaKey = self.encryptRsaKey(rsaKey, self.password)
        print("\nEncryptedRsaKey : " + str(encryptedRsaKey))

        encryptedSessionKey = self.encryptSessionKey(sessionKey, rsaKey)
        print("\nEncrypted sessionkey : " + str(encryptedSessionKey))

        hash, signature = self.signMsg(self.msg, rsaKey)
        print("\nThe signature is : " + str(hex(signature)) + "\nThe hash is : " + str(hash))

        ciphertext, tag, nonce = self.encryptMsg(self.msg, sessionKey)
        print("\nEncrypted tag : " + str(tag) + " ; msg : " + str(ciphertext))


        ##############Reciving side############## Getting ciphertext, tag, nonce, encryptedRsaKey, encryptedSessionKey
        print("\n\n##############Reciving side############## ")
        decryptedRsaKey = self.decryptRsaKey(encryptedRsaKey, self.password)
        print("\nDecryptedRsaKey : " + str(decryptedRsaKey))
        print("\n\tIs the decryptedRsaKey and original key the same: ", rsaKey == decryptedRsaKey)

        verifyAnswer = self.verifyRsaSignature(hash, signature, rsaKey)
        print("\nIs the msg valid : " + str(verifyAnswer))
        #Control with tampered msg
        tamperedHash = int.from_bytes(sha256(self.msgTamper).digest(), byteorder='big')
        verifyAnswer = self.verifyRsaSignature(tamperedHash, signature, rsaKey)
        print("\tIs the tampered msg valid TESTER : " + str(verifyAnswer))

        decryptedSessionKey = self.decryptSessionKey(encryptedSessionKey, decryptedRsaKey)
        print("\nDecrypted sessionkey : " + str(decryptedSessionKey))
        print("\n\tIs the decrypted sessionkey and original sessionkey the same: ", sessionKey == decryptedSessionKey)

        decryptedMsg = self.decryptMsg(ciphertext, tag, nonce, decryptedSessionKey)
        print("\n\nDecrypted msg : " + decryptedMsg.decode("utf-8"))


    def rsa_psa_withLib(self):
        print("Assignment1 Part2 Part2 : Starting rsa_psa")

        ##############Preparing##############
        print("\n\n##############Preparing##############")
        rsaKey = self.rsakey_gen()
        print(f"\nPublic key:  (n={hex(rsaKey.n)}, e={hex(rsaKey.e)})")
        print(f"\nPrivate key: (n={hex(rsaKey.n)}, d={hex(rsaKey.d)})")

        sessionKey = self.sessionKey_gen()
        print("\nSessionKey : " + str(sessionKey)) 


        ##############Sending side##############
        print("\n\n##############Sending side############## ")
        encryptedRsaKey = self.encryptRsaKey(rsaKey, self.password)
        print("\nEncryptedRsaKey : " + str(encryptedRsaKey))

        encryptedSessionKey = self.encryptSessionKey(sessionKey, rsaKey)
        print("\nEncrypted sessionkey : " + str(encryptedSessionKey))

        hash, signature = self.signMsg(self.msg, rsaKey)
        print("\nThe signature is : " + str(hex(signature)) + "\nThe hash is : " + str(hash))

        ciphertext, tag, nonce = self.encryptMsg(self.msg, sessionKey)
        print("\nEncrypted tag : " + str(tag) + " ; msg : " + str(ciphertext))


        ##############Reciving side############## Getting ciphertext, tag, nonce, encryptedRsaKey, encryptedSessionKey
        print("\n\n##############Reciving side############## ")
        decryptedRsaKey = self.decryptRsaKey(encryptedRsaKey, self.password)
        print("\nDecryptedRsaKey : " + str(decryptedRsaKey))
        print("\n\tIs the decryptedRsaKey and original key the same: ", rsaKey == decryptedRsaKey)

        verifyAnswer = self.verifyRsaSignature(hash, signature, rsaKey)
        print("\nIs the msg valid : " + str(verifyAnswer))
        #Control with tampered msg
        tamperedHash = int.from_bytes(sha256(self.msgTamper).digest(), byteorder='big')
        verifyAnswer = self.verifyRsaSignature(tamperedHash, signature, rsaKey)
        print("\tIs the tampered msg valid TESTER : " + str(verifyAnswer))

        decryptedSessionKey = self.decryptSessionKey(encryptedSessionKey, decryptedRsaKey)
        print("\nDecrypted sessionkey : " + str(decryptedSessionKey))
        print("\n\tIs the decrypted sessionkey and original sessionkey the same: ", sessionKey == decryptedSessionKey)

        decryptedMsg = self.decryptMsg(ciphertext, tag, nonce, decryptedSessionKey)
        print("\n\nDecrypted msg : " + decryptedMsg.decode("utf-8"))






    def rsakey_gen(self):
        random_gen = get_random_bytes
        rsaKey = RSA.generate(self.rsa_Moduli, random_gen)
        return rsaKey

    def costume_rsakey_gen(self): #####!!!!! SOMETHING IS WRONG !!!!!!##### Example using Robin Millers, instead of Carmichael's totient function.
        # Step 1: Create two prime numbers, p and q. Calculate n = p * q.
        print('Generating p prime...')
        p = self.generateLargePrime(self.rsa_Moduli)
        print('Generating q prime...')
        q = self.generateLargePrime(self.rsa_Moduli)
        n = p * q
            
        # Step 2: Create a number e that is relatively prime to (p-1)*(q-1).
        print('Generating e that is relatively prime to (p-1)*(q-1)...')
        while True:
            e = random.randrange(2 ** (self.rsa_Moduli - 1), 2 ** (self.rsa_Moduli))
            if self.gcd(e, (p - 1) * (q - 1)) == 1:
                break
        
        # Step 3: Calculate d, the mod inverse of e.
        print('Calculating d that is mod inverse of e...')
        d = self.findModInverse(e, (p - 1) * (q - 1))
        publicKey = (n, e)
        privateKey = (n, d)
        
        rsaKey = RSA.RsaKey
        rsaKey.n = n
        rsaKey.e = e
        rsaKey.d = d

        rsaKey.p = p
        rsaKey.q = q
        rsaKey.u = self.rsa_Moduli #We don't know u : number of prime factors of the RSA modulus, u >= 2

        print('Public key:', publicKey)
        print('Private key:', privateKey)
        # return (publicKey, privateKey)
        return rsaKey


    def gcd(self, a, b):
        while a != 0:
            a, b = b % a, a
        return b

    def findModInverse(self, a, m):
        if self.gcd(a, m) != 1:
            return None
        u1, u2, u3 = 1, 0, a
        v1, v2, v3 = 0, 1, m
        
        while v3 != 0:
            q = u3 // v3
            v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
        return u1 % m

    def rabinMiller(self, num):
        s = num - 1
        t = 0
        
        while s % 2 == 0:
            s = s // 2
            t += 1
        for trials in range(5):
            a = random.randrange(2, num - 1)
            v = pow(a, s, num)
            if v != 1:
                i = 0
                while (v != (num - 1)):
                    if i == t - 1:
                        return False
                    else:
                        i = i + 1
                        v = (v ** 2) % num
            return True


    def isPrime(self, num):
        if (num < 2):#7
            return False

        lowPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 
        67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 
        157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 
        251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,317, 331, 337, 347, 349, 
        353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 
        457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 
        571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 
        673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 
        797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 
        911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
            
        if (num in lowPrimes):
            return True
        for prime in lowPrimes:
            if (num % prime == 0):
                return False
        return self.rabinMiller(num)

    def generateLargePrime(self, keysize = 1024):
        while True:
            num = random.randrange(2**(keysize-1), 2**(keysize))
            if self.isPrime(num):
                return num


    def sessionKey_gen(self):
        sessionKey = get_random_bytes(self.rsa_Salt)
        return sessionKey       


    def signMsg(self, msg,  rsaKey):
        hash = int.from_bytes(sha256(msg).digest(), byteorder='big')
        signature = pow(hash, rsaKey.d, rsaKey.n)
        return hash, signature

    def verifyRsaSignature(self, hash, signature, rsaKey):
        hashFromSignature = pow(signature, rsaKey.e , rsaKey.n)
        if(hash == hashFromSignature):
            return True
        else:
            return False

        

    def encryptRsaKey(self, rsaKey, password):
        encryptedRsaKey = rsaKey.export_key(passphrase=password, pkcs=8, protection="scryptAndAES128-CBC")
        return encryptedRsaKey

    def decryptRsaKey(self, encryptedRsaKey, password):
        decryptedRsaKey = RSA.import_key(encryptedRsaKey, password)
        return decryptedRsaKey


    def encryptSessionKey(self, sessionKey, rsaKey):
        cipher_rsa = PKCS1_OAEP.new(rsaKey)
        encryptedSessionKey = cipher_rsa.encrypt(sessionKey)
        return encryptedSessionKey

    def decryptSessionKey(self, encryptedSessionKey, rsaKey):
        cipher_rsa = PKCS1_OAEP.new(rsaKey)
        decryptedSessionKey = cipher_rsa.decrypt(encryptedSessionKey)
        return decryptedSessionKey


    def encryptMsg(self, msg, sessionKey):
        cipher_aes = AES.new(sessionKey, AES.MODE_EAX)
        ciphertext, tag = cipher_aes.encrypt_and_digest(msg)
        nonce = cipher_aes.nonce
        return ciphertext, tag, nonce

    def decryptMsg(self, ciphertext, tag, nonce, decryptedSessionKey):
        cipher_aes = AES.new(decryptedSessionKey, AES.MODE_EAX, nonce)
        decryptMsg = cipher_aes.decrypt_and_verify(ciphertext, tag)
        return decryptMsg




    
