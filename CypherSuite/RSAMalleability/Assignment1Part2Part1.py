import requests
from Crypto.Util.number import getPrime, GCD, inverse

import base64
import string
import os

os.system('clc' if os.name == 'nt' else 'clear')
import platform
import subprocess 
import json
import random
import math
import fnmatch
import sys
import binascii



class Assignment1Part2Part1(object):
    LocalPort = ":5000/"
    ServerPORT = ":5001/"
    URL_Local = "http://127.0.0.1"
    URL_ServerDNS1 = "http://andreasahn.duckdns.org"
    URL_ServerDNS2 = "http://andreasahn.asuscomm.com"
    URL_ServerIP = "http://84.238.78.202"
    URL = ""
    public_key = {}
    grade= {}
    N = 0
    e = 0
    result = b''
    bits= 0
    cookie= ''
    content= ''
    message= 0

    RESULT= 0
    MESSAGE=  f"You got a 12 because you are an excellent student! :)"

    def __init__(self):
        self.userInterface()

    def userInterface(self):
        while(self.URL == ""):
            print("\033c", end="")
            print("Choice a nr.:")
            print("1 : URL Local machine (127.0.0.1)")
            print("2 : AHN-Server DNS1 (andreasahn.duckdns.org)")
            print("3 : AHN-Server DNS2 (andreasahn.asuscomm.com)")
            print("4 : AHN-Server IP (84.238.78.202)")
            print("5 : Costume URL")
            print("6 : Back")
            nr1 = input()

            if nr1 == "1":
                self.URL = self.URL_Local + self.LocalPort
            elif nr1 == "2":
                self.URL = self.URL_ServerDNS1 + self.ServerPORT
            elif nr1 == "3":
                self.URL = self.URL_ServerDNS2 + self.ServerPORT
            elif nr1 == "4":
                self.URL = self.URL_ServerIP + self.ServerPORT
            elif nr1 == "5":
                self.URL = input("Write your new URL:\n\t")
            elif nr1 == "6":
                print("Going back...")
                self.URL = "Back"
            else:
                input("Wrong input, press enter to continue...")
                self.URL = ""

            #Tjecing that server is online
            try:
                if nr1 != 6:
                    print("\nTry connecting to server...")
                    r = requests.get(self.URL)
                    print("Succes!")
            except:
                input("The server ->" + self.URL + "<- is offline, choice another one. Press enter to continue...")
                self.URL = ""  

        choice = "wrong"
        while(choice == "wrong"):
            print("\033c", end="")
            print("Using URL : " + str(self.URL))
            print("\nChoice a nr.:")
            print("1 : Obtain a 12 grade with the message, regularly signed")
            print("2 : Try enc-dec some examples")
            print("3 : Try obtain d with brute force") 
            print("4 : Back")
            nr2 = input()
            if nr2 == 1 or nr2 == 2 or nr2 == 3:
                choice = "right"

            if nr2 == "1":
                r = requests.get(self.URL + 'pk/')
                self.public_key = json.loads(r.content)
                self.N = self.public_key['N']
                self.e = self.public_key['e']
                self.bits = self.calc_bits()
                
                r = requests.get(self.URL + "grade/")
                cookie = r.cookies['grade']
                c = self.cookie_to_json(cookie)
                j = json.loads(c)
                msg = bytes.fromhex(j['msg'])
                signature = bytes.fromhex(j['signature'])
                print ("\nFirst grade: ", msg.decode('utf8'))

                the_message = f"You got a 12 because you are an excellent student! :)"
                sigHex2= the_message.encode().hex()
                signed2= bytes.fromhex(sigHex2)
                signed2= int.from_bytes(signed2, 'big')

                print ("\nReference message: ", signed2)

                divider = 1

                for x in range(2,100):
                
                    if signed2% x == 0:
                        print ("Multiplier : ", x)
                        divider= x
                        break

                div= signed2 // divider

                print ("\nVerify original message: ", div*5)

                signed2= div % self.N

                print ("\nReady for sign: ", signed2)
            
                the_message= hex(signed2)[2:]
                msg, signed2 = self.signHex(the_message)
                print ("\nMain message in clear: ", int.from_bytes(bytes.fromhex(msg),'big'))
                signed2= int(signed2, 16)
            
                ack_hex = "05"
                msg, signedx = self.signHex(ack_hex)
                print ("\nMultiplier in clear: ", int.from_bytes(bytes.fromhex(msg),'big'))
                signedx= int.from_bytes(bytes.fromhex(signedx),byteorder= 'big')

                mul= (signed2*signedx)
                modulus= mul % self.N

                print ("\nSigned Mul: ") 
                self.dec([modulus])

                print ("\nSigned Divided: ") 
                self.dec([signed2])

                response = self.sendCookieToServer(self.MESSAGE.encode().hex(), format(modulus,"x"), 'grade', '/quote/')         
                print ("\nResponse: ", response.content)
                
                input("\n\npress enter to continue...")

            elif nr2 == "2":
                messages = [3]
                r = requests.get(self.URL + 'pk/')
                self.public_key = json.loads(r.content)
                self.N = self.public_key['N']
                self.e = self.public_key['e']
                self.see_pk()
                self.bits = self.calc_bits() 
                self.encdec(messages)
                input("\n\npress enter to continue...")
            
            elif nr2 == "3":
                messages = [5]
                r = requests.get(self.URL + 'pk/')
                self.public_key = json.loads(r.content)
                self.N = self.public_key['N']
                self.e = self.public_key['e']    
                self.brute_key_obt(messages)
                input("\n\npress enter to continue...")

            elif nr2 == "4":
                print("Going back...")
                choice = "back"

            else:
                input("Wrong input, press enter to continue...")
                choice = "wrong"

    

    def json_to_cookie(self, j: str) -> str:
        """Encode json data in a cookie-friendly way using base64."""
        # The JSON data is a string -> encode it into bytes
        json_as_bytes = j.encode()
        # base64-encode the bytes
        base64_as_bytes = base64.b64encode(json_as_bytes, altchars=b'-_')
        # b64encode returns bytes again, but we need a string -> decode it
        base64_as_str = base64_as_bytes.decode()    
        return base64_as_str


    def cookie_to_json(self, base64_as_str: str) -> str:
        """Decode json data stored in a cookie-friendly way using base64."""
        # Check that the input looks like base64 data
        assert all(char in (string.ascii_letters + string.digits + '-_=') for char in base64_as_str), \
                f"input '{base64_as_str}' is no valid base64"
        # decode the base64 data
        json_as_bytes = base64.b64decode(base64_as_str, altchars=b'-_')
        # b64decode returns bytes, we want string -> decode it
        json_as_str = json_as_bytes.decode()
        return json_as_str

    
    def see_pk(self):
        print("\nPublic key : " + str(self.public_key))

    def calc_bits(self):
        temp= 0
        e= 0
        
        while temp < self.N:
            e= e+1
            temp= pow(2,e)         
        
        return e-1
    
    def dec(self, cipher):

        e= self.e
        N= self.N
        dec= 0

        for m in cipher:
            m = m % N
            dec = pow(m, e, N)
            print("\nRSA plaintext: ", dec) 
        
        return dec


    def encdec(self, messages):
        p= 0
        q= p
        e= self.e
        phi= 0

        while p == q or GCD(e, phi) > 1:
            p = getPrime(self.bits // 2)
            q = getPrime(self.bits // 2)
        
            N = p * q
            phi = (p - 1) * (q - 1)   

        d = inverse(e,phi)

        for i in messages:

            m = i % N
            enc = pow(m, e, N)         
            dec = pow(enc, d, N)
            self.RESULT= dec

            print("\nRSA plaintext: ", dec)

    def brute_key_obt(self, messages):
        p= 0
        q= p
        e= self.e
        phi= 0
        N= self.N

        rangenum = range(1, N)
        primes = []
        for y in rangenum[1:]:
            x = y
            div= []
            for x in range(2, x):
                if (y/x).is_integer():
                    div.append(x)
            
            if len(div) < 1:
                primes.append(y)
                print (y)

        primesP1= primes[:len(primes)/2]
        primesP2= primes[len(primesP1):]
        counter= 0
        primesmatch= []


        print (primesP1)
        print (primesP2)

        for x in primesP2:
            
            for y in primesP1:
                temp= x*y
                counter= counter+1
                print ("Counter: ", counter)

                if N == temp:
                    primesmatch.append(temp)
        
        dmatch=  []
                    
        for x in primesmatch:
            while p == q or GCD(e, phi) > 1:
                p = getPrime(self.bits // 2)
                q = getPrime(self.bits // 2)
                N = p * q
                phi = (p - 1) * (q - 1)   

            dmatch.append(inverse(e,phi))

        for x in dmatch:
            print("\nPrivate exponent d: ", x)


        for i in messages:

            for x in dmatch:

                m = i % N
                enc = pow(m, e, N)
                dec = pow(enc, x, N)
                print("\nRSA plaintext: ", dec)

    def sendCookieToServer(self, message, signature, cookiename, path):
        j = json.dumps({'msg': message, 'signature': signature})
        # encode the json data cookie-friendly using base 64
        c = self.json_to_cookie(j)
        # and store the created JSON object into a cookie
        # create a response object
        session = requests.Session()
        cookie_obj = requests.cookies.create_cookie(name=cookiename,value=c)
        session.cookies.set_cookie(cookie_obj)
        response = session.get(self.URL + path)
        
        return response


    def signHex(self, hexed):
        response = requests.get(self.URL + f"sign_random_document_for_students/{hexed}/")
        jsoned = json.loads(response.content)
        return jsoned["msg"], jsoned["signature"]


